/**
 * EAN Merge Script
 *
 * Merges EAN mappings from various sources into the main paints.json database.
 *
 * Supported input formats:
 * 1. ean-mappings.json - Full mapping file with confidence levels
 * 2. *-ean-mapping-*.json - Direct paintId→EAN mapping (e.g., from vallejo generator)
 *
 * Usage:
 *   npm run ean:merge
 *   npm run ean:merge -- --include-low  # Include low confidence matches
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import type { Paint, PaintDatabase } from '../../src/types/paint';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const CONFIG = {
  paintsFile: path.join(__dirname, '../../src/data/paints.json'),
  mappingsFile: path.join(__dirname, '../../data/ean-mappings.json'),
  eanScrapeDir: path.join(__dirname, '../../data/ean-scrape'),
  backupDir: path.join(__dirname, '../../data/backups'),
};

// Types
interface EanMapping {
  paintId: string;
  paintName: string;
  brand: string;
  productLine: string;
  ean: string | null;
  matchConfidence: 'exact' | 'high' | 'low' | 'manual' | 'none';
  source: 'upcitemdb' | 'manual';
  matchedTitle?: string;
  lookupDate: string;
}

interface MappingFile {
  version: string;
  generatedAt: string;
  stats: {
    total: number;
    matched: number;
    notFound: number;
    needsReview: number;
    byBrand: Record<string, { total: number; matched: number }>;
  };
  mappings: EanMapping[];
}

// EAN/UPC validation - accepts both EAN-13 (13 digits) and UPC-A (12 digits)
const BARCODE_REGEX = /^\d{12,13}$/;

function isValidEan(ean: string | null | undefined): boolean {
  if (!ean) return false;
  return BARCODE_REGEX.test(ean);
}

function loadPaintsDatabase(): PaintDatabase {
  const content = fs.readFileSync(CONFIG.paintsFile, 'utf-8');
  return JSON.parse(content) as PaintDatabase;
}

function loadMappings(): MappingFile | null {
  if (!fs.existsSync(CONFIG.mappingsFile)) {
    return null;
  }
  const content = fs.readFileSync(CONFIG.mappingsFile, 'utf-8');
  return JSON.parse(content) as MappingFile;
}

/**
 * Load direct mapping files (paintId → EAN)
 * These are generated by brand-specific scripts like generate-vallejo-eans.ts
 */
function loadDirectMappings(): Map<string, string> {
  const mappings = new Map<string, string>();

  if (!fs.existsSync(CONFIG.eanScrapeDir)) {
    return mappings;
  }

  // Find all *-ean-mapping-*.json files
  const files = fs.readdirSync(CONFIG.eanScrapeDir).filter((f) => f.includes('-ean-mapping-') && f.endsWith('.json'));

  for (const file of files) {
    const filePath = path.join(CONFIG.eanScrapeDir, file);
    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const data = JSON.parse(content) as Record<string, string>;

      let count = 0;
      for (const [paintId, ean] of Object.entries(data)) {
        if (isValidEan(ean)) {
          mappings.set(paintId, ean);
          count++;
        }
      }
      console.log(`  Loaded ${count} mappings from ${file}`);
    } catch {
      console.warn(`  Warning: Failed to load ${file}`);
    }
  }

  return mappings;
}

function createBackup(database: PaintDatabase): string {
  if (!fs.existsSync(CONFIG.backupDir)) {
    fs.mkdirSync(CONFIG.backupDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupPath = path.join(CONFIG.backupDir, `paints-${timestamp}.json`);
  fs.writeFileSync(backupPath, JSON.stringify(database, null, 2));
  return backupPath;
}

async function main(): Promise<void> {
  // Parse CLI arguments
  const args = process.argv.slice(2);
  const includeLow = args.includes('--include-low');

  console.log('Loading paints database...');
  const database = loadPaintsDatabase();
  console.log(`Loaded ${database.paints.length} paints`);

  // Load direct mappings first (highest priority - algorithmically generated)
  console.log('\nLoading direct EAN mappings...');
  const directMappings = loadDirectMappings();
  console.log(`Total direct mappings: ${directMappings.size}`);

  // Load structured mappings file
  console.log('\nLoading structured EAN mappings...');
  const mappings = loadMappings();

  if (!mappings && directMappings.size === 0) {
    console.error('No mappings found. Run ean:match or ean:generate:vallejo first.');
    process.exit(1);
  }

  if (mappings) {
    console.log(`Loaded ${mappings.mappings.length} structured mappings`);
    console.log(`Stats: ${mappings.stats.matched} matched, ${mappings.stats.needsReview} need review`);
  }

  // Create backup before modifying
  console.log('\nCreating backup...');
  const backupPath = createBackup(database);
  console.log(`Backup saved to: ${backupPath}`);

  // Build mapping lookup from structured mappings
  const eanLookup = new Map<string, EanMapping>();
  if (mappings) {
    for (const mapping of mappings.mappings) {
      eanLookup.set(mapping.paintId, mapping);
    }
  }

  // Determine which confidence levels to include
  const acceptedConfidences = new Set(['exact', 'high', 'manual']);
  if (includeLow) {
    acceptedConfidences.add('low');
    console.log('\nIncluding low confidence matches (--include-low flag)');
  }

  // Apply mappings
  console.log('\nMerging EAN data...');
  let mergedDirect = 0;
  let mergedStructured = 0;
  let skippedLowConfidence = 0;
  let skippedInvalidEan = 0;
  let alreadyHasEan = 0;

  for (const paint of database.paints) {
    // First check direct mappings (highest priority - algorithmically generated)
    const directEan = directMappings.get(paint.id);
    if (directEan) {
      if (paint.ean && paint.ean === directEan) {
        alreadyHasEan++;
        continue;
      }
      paint.ean = directEan;
      mergedDirect++;
      continue;
    }

    // Fall back to structured mappings
    const mapping = eanLookup.get(paint.id);

    if (!mapping || !mapping.ean) {
      continue;
    }

    // Skip if confidence too low
    if (!acceptedConfidences.has(mapping.matchConfidence)) {
      skippedLowConfidence++;
      continue;
    }

    // Validate EAN format
    if (!isValidEan(mapping.ean)) {
      console.warn(`Invalid EAN for ${paint.name}: ${mapping.ean}`);
      skippedInvalidEan++;
      continue;
    }

    // Check if paint already has EAN
    if (paint.ean && paint.ean === mapping.ean) {
      alreadyHasEan++;
      continue;
    }

    // Apply EAN
    paint.ean = mapping.ean;
    mergedStructured++;
  }

  // Update database metadata
  database.generatedAt = new Date().toISOString();

  // Write updated database
  console.log('\nWriting updated paints database...');
  fs.writeFileSync(CONFIG.paintsFile, JSON.stringify(database, null, 2));

  // Print summary
  console.log('\n' + '='.repeat(60));
  console.log('MERGE SUMMARY');
  console.log('='.repeat(60));
  console.log(`EANs merged (direct):      ${mergedDirect}`);
  console.log(`EANs merged (structured):  ${mergedStructured}`);
  console.log(`Total merged:              ${mergedDirect + mergedStructured}`);
  console.log(`Already had EAN:           ${alreadyHasEan}`);
  console.log(`Skipped (low conf):        ${skippedLowConfidence}`);
  console.log(`Skipped (invalid):         ${skippedInvalidEan}`);

  // Count final coverage
  const paintsWithEan = database.paints.filter((p) => p.ean).length;
  const coverage = ((paintsWithEan / database.paints.length) * 100).toFixed(1);
  console.log(`\nFinal coverage: ${paintsWithEan}/${database.paints.length} (${coverage}%)`);

  // Coverage by brand
  console.log('\nCoverage by brand:');
  const brandCoverage = new Map<string, { total: number; withEan: number }>();
  for (const paint of database.paints) {
    const stats = brandCoverage.get(paint.brand) || { total: 0, withEan: 0 };
    stats.total++;
    if (paint.ean) stats.withEan++;
    brandCoverage.set(paint.brand, stats);
  }
  for (const [brand, stats] of brandCoverage) {
    const pct = ((stats.withEan / stats.total) * 100).toFixed(1);
    console.log(`  ${brand}: ${stats.withEan}/${stats.total} (${pct}%)`);
  }

  console.log(`\nPaints database updated: ${CONFIG.paintsFile}`);
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
